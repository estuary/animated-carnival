-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE OR REPLACE FUNCTION public.auth_catalog(IN name_or_prefix text,IN min_cap grant_capability)
    RETURNS boolean
    LANGUAGE 'sql'
    STABLE
    PARALLEL UNSAFE
    COST 100

AS $BODY$
  select exists(
    select 1 from auth_roles() r
    where internal.istarts_with(name_or_prefix, r.role_prefix) and r.capability >= min_cap
  )
$BODY$;

DROP INDEX IF EXISTS public.idx_live_specs_catalog_name;

CREATE UNIQUE INDEX IF NOT EXISTS idx_live_specs_catalog_name
    ON public.live_specs USING btree
    (lower(catalog_name::text) COLLATE pg_catalog."default" text_pattern_ops ASC NULLS LAST)
    TABLESPACE pg_default;


CREATE OR REPLACE FUNCTION internal.live_specs_catalog_name_prefix_check()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
AS $BODY$
declare
  -- Found name which conflicts with the proposed `live_specs.catalog_name`
  conflict_name text;
begin
  -- Search for an existing row which is a case-invariant prefix match of the proposed row.
  select cur.catalog_name into conflict_name from live_specs as cur
  where
    internal.istarts_with(new.catalog_name, cur.catalog_name || '/') or
    internal.istarts_with(cur.catalog_name, new.catalog_name || '/')
  limit 1;

  if found then
    raise 'Conflicting catalog names: % vs %', new.catalog_name, conflict_name
      using errcode = 'unique_violation';
  end if;

  return new;
end;
$BODY$;

ALTER FUNCTION internal.live_specs_catalog_name_prefix_check()
    OWNER TO postgres;



CREATE TRIGGER live_specs_catalog_name_prefix_check
    BEFORE INSERT OR UPDATE OF catalog_name
    ON public.live_specs
    FOR EACH ROW
    EXECUTE FUNCTION internal.live_specs_catalog_name_prefix_check();

ALTER TABLE IF EXISTS public.draft_specs DROP CONSTRAINT IF EXISTS draft_specs_draft_id_catalog_name_key;
CREATE UNIQUE INDEX IF NOT EXISTS idx_draft_specs_catalog_name
    ON public.draft_specs USING btree
    (draft_id ASC NULLS LAST, lower(catalog_name::text) COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;

DROP INDEX IF EXISTS public.idx_role_grants_sub_obj;

CREATE UNIQUE INDEX IF NOT EXISTS idx_role_grants_sub_obj
    ON public.role_grants USING btree
    (lower(subject_role::text) COLLATE pg_catalog."default" text_pattern_ops ASC NULLS LAST, lower(object_role::text) COLLATE pg_catalog."default" text_pattern_ops ASC NULLS LAST)
    TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.user_grants DROP CONSTRAINT IF EXISTS user_grants_user_id_object_role_key;
CREATE UNIQUE INDEX IF NOT EXISTS idx_user_grants_user_obj
    ON public.user_grants USING btree
    (user_id ASC NULLS LAST, lower(object_role::text) COLLATE pg_catalog."default" text_pattern_ops ASC NULLS LAST)
    TABLESPACE pg_default;

CREATE OR REPLACE FUNCTION internal.user_roles(IN target_user_id uuid)
    RETURNS TABLE(role_prefix catalog_prefix, capability grant_capability)
    LANGUAGE 'sql'
    STABLE SECURITY DEFINER
    PARALLEL UNSAFE
    COST 100    ROWS 1000

AS $BODY$

  with recursive
  all_roles(role_prefix, capability) as (
      select object_role, capability from user_grants
      where user_id = target_user_id
    union
      -- Recursive case: for each object_role granted as 'admin',
      -- project through grants where object_role acts as the subject_role.
      select role_grants.object_role, role_grants.capability
      from role_grants, all_roles
      where internal.istarts_with(role_grants.subject_role, all_roles.role_prefix)
        and all_roles.capability = 'admin'
  )
  select role_prefix, capability from all_roles;

$BODY$;
